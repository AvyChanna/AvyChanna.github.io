<!doctype html><html lang=en><head><title>Number Theory Primer :: Bits & Pieces —
Shower Thoughts on maths and programming</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A beginner friendly explaination of some select algorithms in number theory. This is, by no means, a complete/detailed post. For more information on these algorithms, consult a reliable source like Wikipedia.
Greatest Common Divisor GCD (also called HCF) finds common divisors of 2 numbers.
 Shortcut -&amp;gt; $ gcd(a,b) = gcd(a\%b, b) $.
 The following is an implementation of Euclidean Algorithm.
def gcd(x, y): &amp;#39;&amp;#39;&amp;#39;finds GCD of 2 positive integers&amp;#39;&amp;#39;&amp;#39; while y: y, x = x % y, y return x # Or simply do -&amp;gt; # from math import gcd # result = gcd(25, 15)  We use divison lemma $a = bq+r$."><meta name=keywords content="mathematics,programming,algorithms,number theory,cryptography,modular arithmetic"><meta name=robots content="noodp"><link rel=canonical href=/posts/number-theory-primer-copy-6/><link rel=stylesheet type=text/css href=/css/style.min.36e7a0968aa3a801d3d9e83707df58e9905d6ca9644771d2a2f2154ed5bc4558.css integrity="sha512-s+JJ6Hc5jnV7K9YIWW31on4wSH9ARw+q4+HS0iJBOac/TJxWCIy3CU8vm5GHJsmKH0bSNWQsJBwt19U6ItuY3g=="><link rel=stylesheet type=text/css href=/css/katex.min.0afe3ec2fccfca51430ecccba66eb647fbf16b1305db8f3120600e02c2dc4e36.css integrity="sha512-OhOypde5f1JRb09plm7e2Ah8qWYobFPGHEuQsdqK2VzNNQDoeL5XeFRQtLBFnQp3Zoh48z4Vg1HIhRckNOYhbA=="><link rel=apple-touch-icon-precomposed sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon-precomposed sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon-precomposed sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon-precomposed sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon-precomposed sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon-precomposed sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon-precomposed sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon-precomposed sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon-precomposed sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=128x128 href=/favicon/favicon-128.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=196x196 href=/favicon/favicon-196x196.png><link rel=manifest href=/favicon/manifest.json><link rel="shortcut icon" href=/favicon/favicon.ico><meta name=application-name content="Bits & Pieces"><meta name=msapplication-square150x150logo content="/favicon/mstile-150x150.png"><meta name=msapplication-square310x310logo content="/favicon/mstile-310x310.png"><meta name=msapplication-square70x70logo content="/favicon/mstile-70x70.png"><meta name=msapplication-TileColor content="#ee72f1"><meta name=msapplication-TileImage content="/favicon/mstile-144x144.png"><meta name=msapplication-wide310x150logo content="/favicon/mstile-310x150.png"><meta name=theme-color content="#ee72f1"><link rel=preconnect href=/><link rel=preload as=font href=/fonts/woff2/FiraCode-Regular.woff2 type=font/woff2 crossorigin=anonymous><link rel=preload as=font href=/fonts/woff2/FiraCode-Bold.woff2 type=font/woff2 crossorigin=anonymous><link rel=dns-prefetch href=/><meta http-equiv=cache-control content="max-age=31536000"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Number Theory Primer :: Bits & Pieces"><meta property="og:description" content="A (short) primer on basics of Number theory"><meta property="og:url" content="/posts/number-theory-primer-copy-6/"><meta property="og:site_name" content="Number Theory Primer"><meta property="og:image" content="/favicon/favicon.ico"><meta property="article:published_time" content="2020-05-23 14:49:49 +0530 IST"><link href=/posts/number-theory-primer-copy-6/index.xml rel=alternate type=application/rss+xml title="Bits & Pieces"></head><body><div class=page-wrap><div class="container full center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Bits & Pieces</div></a></div><div class="menu-trigger noselect">menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>Home</a></li><li><a href=/tags>Tags</a></li><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>Home</a></li><li><a href=/tags>Tags</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/number-theory-primer-copy-6/>Number Theory Primer</a></h1><div class=post-meta><span class=post-date>Saturday 05 May, 2020</span></div><span class=post-tags>#<a href=/tags/maths/>maths</a>&nbsp;
#<a href=/tags/number-theory/>number theory</a>&nbsp;</span><div class=post-content><div id=toc_container><p class=toc_title>On this Page</p><hr><br><nav id=TableOfContents><ul><li><a href=#greatest-common-divisor>Greatest Common Divisor</a></li><li><a href=#beacutezouts-identity>Bézout&rsquo;s identity</a></li><li><a href=#extended-euclidean-algorithm>Extended Euclidean Algorithm</a></li><li><a href=#chinese-remainder-theorem>Chinese Remainder Theorem</a></li></ul></nav></div><div><p>A beginner friendly explaination of some select algorithms in number theory.
This is, by no means, a complete/detailed post.
For more information on these algorithms, consult a reliable source like <a href=https://www.wikipedia.org>Wikipedia</a>.</p><h2 id=greatest-common-divisor>Greatest Common Divisor<a href=#greatest-common-divisor class=hanchor arialabel=Anchor>&#8983;</a></h2><p>GCD (also called HCF) finds common divisors of 2 numbers.</p><blockquote><p><strong>Shortcut</strong> -> $ gcd(a,b) = gcd(a\%b, b) $.</p></blockquote><p>The following is an implementation of Euclidean Algorithm.</p><pre class="language-python line-numbers diff-highlight" data-start=1><code class="language-python diff-highlight">def gcd(x, y):
	&#39;&#39;&#39;finds GCD of 2 positive integers&#39;&#39;&#39;
	while y:
		y, x =  x % y, y
	return x
# Or simply do -&gt;
# from math import gcd
# result = gcd(25, 15)
</code></pre><p>We use divison lemma $a = bq+r$.
In next iteration, put $a = b$ and $b = r$ and repeat till $r = 0$.</p><p>Let us define 2 sequences $\{q_i\}$, $\{r_i\}$,
such that $r_{i-2} = r_{i-1}q_{i}+r_i$,
where $\{r_i\}$ is the squence of remainders in integer division,
with $r_{0}=a$ and $r_{1}=b$ as our initial conditions.</p><p>We iterate this seqence $i$ times till we reach $r_{i-1} = 0$.
The term $r_{i-2}$ is the required GCD.</p><p><em>Example</em> - $gcd(100, 26)$</p><p><div id=table-style-1><table><thead><tr><th>Expression($a=bq+r$)</th><th>$ b$</th><th>$ r$</th></tr></thead><tbody><tr><td>$100 = 3 \times 26 + 22$</td><td>$26$</td><td>$22$</td></tr><tr><td>$ 26 = 1 \times 22 + 4$</td><td>$22$</td><td>$ 4$</td></tr><tr><td>$ 22 = 5 \times 4 + 2$</td><td>$ 4$</td><td>$ 2$</td></tr><tr><td>$ 4 = 2 \times 2 + 0$</td><td>$ 2$</td><td>$ 0$</td></tr></tbody></table></div><style>#table-style-1 table th:nth-of-type(1){width:80%}#table-style-1 table th:nth-of-type(2){width:10%}#table-style-1 table th:nth-of-type(3){width:10%}</style>Here, $\{r_i\} = \{100, 26, 22, 4, 2, 0\}$ and $\{q_i\} = \{3, 1, 5, 2\}$.</p><p>Note that, $gcd(a,b) = gcd(r_0,r_1) = gcd(r_1,r_2) = &mldr; = gcd(r_{-3},r_{i-2})$ and $gcd(r_{i-1}) = 0$</p><p>So, $gcd(100, 26) = 2$</p><h2 id=beacutezouts-identity>Bézout&rsquo;s identity<a href=#beacutezouts-identity class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>Theorem -</strong> for two integers $a$ & $b$, $\exists$ integers $x$ & $y$ such that $ax+by=d$,
where $d=gcd(a,b)$</p><p>Moreover all integers of the type $ax+by$ are divisible by $d$.
Note that Bézout coefficients($x$ and $y$) are not unique.</p><p><em>For example</em>, for $a=3$ and $b=5$, we have $d=1$ and $2a-b=d$.
This means $(x, y)=(2,-1)$ is one solution.
Ofcourse, all pairs of the form $(2+5k,-1-3k)$ are valid coefficients.</p><p>The simplest way to find one of these pairs is by using <a href=#extended-euclidean-algorithm>Extended Euclidean Algorithm</a>,
with $|x| \le \left | \frac{b}{d}\right |$ and $|y|\le\left |\frac{a}{d}\right |$.
For a given solution $(x,y)$, we can generate all possible coefficients by using $\left(x+k\frac{b}{d},\ y-k\frac{a}{d}\right)$,
for any integer $k$ where all these fractions simplify to integers.</p><p>Convince yoursef.
Hint -
<span class=spoiler>Let $ax_0+by_0=0$ be for some $(x_0,y_0)$.
For all integer $k$, $ax+by = (ax+by)+k\cdot(ax_0+by_0)$, so new solutions will be of the form $(x+kx_0,y+ky_0)$</span></p><blockquote><p><strong>Shortcut</strong> - If $gcd(n_1,n_2) = 1$, then $x \equiv n_{1}^{-1} (mod~n_2)$ and $y \equiv n_{2}^{-1} (mod~n_1)$</p></blockquote><h2 id=extended-euclidean-algorithm>Extended Euclidean Algorithm<a href=#extended-euclidean-algorithm class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This is an extension of <a href=#greatest-common-divisor>Euclidean Algorithm</a>,
which also provides Bézout coefficients along with the GCD.</p><p>It also uses Euclidean algorithm, but also finds r as a linear combination of $a$ and $b$</p><p>Let us define 4 sequences $\{q_i\}$, $\{r_i\}$, $\{x_i\}$, $\{y_i\}$.
The sequences $\{q_i\}$, $\{r_i\}$ are the same ones from Euclidean Algorithm,
that is, $r_{i-2} = r_{i-1}q_{i}+r_i$, $r_0=a$, $r_1=b$, $r_{i-1} = 0$ for some i.
We also need to write $r_i$ as linear combination of $a$ and $b$, such that $r_i = x_ia+y_ib$</p><p>Now, $r_i = r_{i-2}-r_{i-1}q_i$ and $r_i = x_ia+y_ib$</p><p>Substituting values of $r$ in $x$ and $y$, we get
$(x_ia+y_ib) = (x_{i-2}a+y_{i-2}b) - (x_{i-1}a+y_{i-1}b)q_i$,
which gives us the relations</p><p>$x_i = x_{i-2} - x_{i-1}q_i$ and $y_i = y_{i-2} - y_{i-1}q_i$</p><p>Also, $r_0 = a = x_0a+y_0b$ and $r_1 = b = x_1a+y_ib$,
which gives us inital values $x_0=1$, $y_0=0$, $x_1=0$, $y_1=1$,</p><pre class="language-python line-numbers diff-highlight" data-start=1><code class="language-python diff-highlight">def egcd(a, b):
	# returns (GCD(a, b), x, y)
	# where x &amp; y follow ax &#43; by = GCD(a, b)
	old_x, new_x = 1, 0
	old_y, new_y = 0, 1
	while a != 0:
		q, a, b = b//a, b%a, a # From division lemma
		new_x, old_x = old_x, new_x - q * old_x
		new_y, old_y = old_y, new_y - q * old_y
	return b, new_x, new_y
</code></pre><h2 id=chinese-remainder-theorem>Chinese Remainder Theorem<a href=#chinese-remainder-theorem class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Theorem - Given $n_1, n_2, &mldr; , n_i$ pairwise co-prime positive integers
(all numbers are co-prime to each other),
with $N$ = product of all $n_i$, =
and $a_1, a_2, &mldr; , a_i$ integers with $0 \le a_i \lt n_i$ for each $i$,
then there is one and only one positive integer $x$ in $0 \le x \lt N$,
such that remainder of integer divison of $x$ by $n_j$ is $a_j$ for every j.</p><p>In other words, there is always a unique solution for x between $0$ and $N$ for -
$$
\begin{aligned}
x \equiv & n_0 (mod~a_0) \\
x \equiv & n_1 (mod~a_1) \\
& \vdots \\
x \equiv & n_i (mod~a_i)
\end{aligned}
$$</p><p>Let us first solve it for 2 moduli only,
say $x \equiv a_1 (mod~n_1)$ and $x \equiv a_2 (mod~n_2)$.
Then using <a href=#b%C3%A9zouts-identity>Bézout&rsquo;s Identity</a>,
there exists integers $m_1$ and $m_2$ such that $m_1n_1 + m_2n_2 = 1$.
We can easily verify that the solution to this equation is $x \equiv a_1m_2n_2+a_2m_1n_1 (mod~n_1n_2)$</p><p>For n equations, we can apply the above result n-1 times,
since the resultant modulus($n_1n_2$) will also be co-prime to other remaining moduli.</p><blockquote><p><strong>Single Step Computation</strong> - For $k$ equations, $x \equiv \displaystyle\sum_{i=1}^{k}a_iM_iN_i~(mod~N)$, where $N = \displaystyle\prod_{i=1}^{k} n_i$, $N_i = \dfrac{N}{n_i}$ and $M_iN_i + m_in_i = 1$(from Bézout&rsquo;s Identity) or directly, $M_i = N_i^{-1} (mod~n_i)$</p></blockquote><p>This single step computation may not be very useful, because as we increase the number of moduli, their product becomes very large for efficient computation.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/number-theory-primer-copy-5/><span class=button__icon>&#8592;</span>
<span class=button__text>Number Theory Primer</span></a></span>
<span class="button next"><a href=/posts/number-theory-primer-copy-7/><span class=button__text>Number Theory Primer</span>
<span class=button__icon>&#8594;</span></a></span></div></div></div></div></div></div><footer class=footer><div class=footer__inner><a class=go-to-top href=javascript:void(0); onclick=window.scroll(0,0);>Back to Top</a></div></footer><script async defer src=/js/bundle.js></script><script async defer src=/js/katex.js></script></body></html>